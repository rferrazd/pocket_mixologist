"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AppError_1 = __importDefault(require("../../../common/errors/AppError"));
const resource_1 = __importDefault(require("../../../common/resource"));
const JitsiMeet_1 = __importDefault(require("../../../util/jitsi/JitsiMeet"));
class Session extends resource_1.default {
    constructor(token, url, domain) {
        super(token, url);
        this.url = `${this.url}/sessions`;
        this.sessionCurrent = null;
        this.domain = domain;
    }
    create(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request.post(`${this.url}`, data, { headers: { Authorization: this.token ? `Bearer ${this.token}` : '' } })
                .then((res) => res.data)
                .catch((err) => { throw new AppError_1.default(err.response.data, err.response.status); });
        });
    }
    get(session) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request.get(`${this.url}/${session}`, { headers: { Authorization: this.token ? `Bearer ${this.token}` : '' } })
                .then((res) => res.data)
                .catch((err) => { throw new AppError_1.default(err.response.data, err.response.status); });
        });
    }
    list(filters) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request.post(`${this.url}/list`, filters, { headers: { Authorization: this.token ? `Bearer ${this.token}` : '' } })
                .then((res) => res.data)
                .catch((err) => { throw new AppError_1.default(err.response.data, err.response.status); });
        });
    }
    listByUser(filters) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request.post(`${this.url}/users/overview`, filters, { headers: { Authorization: this.token ? `Bearer ${this.token}` : '' } })
                .then((res) => res.data)
                .catch((err) => { throw new AppError_1.default(err.response.data, err.response.status); });
        });
    }
    update(session, data) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.request.patch(`${this.url}/${session}`, data, { headers: { Authorization: this.token ? `Bearer ${this.token}` : '' } })
                .catch((err) => { throw new AppError_1.default(err.response.data, err.response.status); });
        });
    }
    delete(session) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.request.delete(`${this.url}/${session}`, { headers: { Authorization: this.token ? `Bearer ${this.token}` : '' } })
                .catch((err) => { throw new AppError_1.default(err.response.data, err.response.status); });
        });
    }
    join(session, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request.post(`${this.url}/${session}/JOIN`, data, { headers: { Authorization: this.token ? `Bearer ${this.token}` : '' } })
                .then((res) => res.data)
                .catch((err) => { throw new AppError_1.default(err.response.data, err.response.status); });
        });
    }
    startConference(session, options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const info = !options.sessionToken ? yield this.join(session, {
                firstName: options.userInfo ? options.userInfo.displayName : undefined,
                moderator: options.moderator,
                avatarUrl: options.userInfo ? options.userInfo.avatarUrl : undefined,
            }) : undefined;
            this.conference = this.conference ? this.conference : new JitsiMeet_1.default();
            this.sessionCurrent = session;
            yield this.conference.startConference(Object.assign({ jwt: (_a = info === null || info === void 0 ? void 0 : info.sessionToken) !== null && _a !== void 0 ? _a : options.sessionToken, roomName: (_b = info === null || info === void 0 ? void 0 : info.short) !== null && _b !== void 0 ? _b : session, domain: this.domain }, options));
        });
    }
    getSessionPartCount(session) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request.get(`${this.url}/${session}/parts/overview`, { headers: { Authorization: this.token ? `Bearer ${this.token}` : '' } })
                .then((res) => res.data)
                .catch((err) => { throw new AppError_1.default(err.response.data, err.response.status); });
        });
    }
    countParts(session) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request.get(`${this.url}/${session}/parts`, { headers: { Authorization: this.token ? `Bearer ${this.token}` : '' } })
                .then((res) => res.data)
                .catch((err) => { throw new AppError_1.default(err.response.data, err.response.status); });
        });
    }
    stopConference(forEveryone = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.sessionCurrent)
                this.conference.closeConference(forEveryone);
        });
    }
    getNumberOfParticipants() {
        return this.conference.getNumberOfPart();
    }
    toogleLibras() {
        return this.conference.executeCommand('toggleLibras');
    }
    startRecording() {
        return this.conference.executeCommand('startRecording', {
            mode: 'file',
        });
    }
    stopRecording() {
        return this.conference.executeCommand('stopRecording', {
            mode: 'file',
        });
    }
}
exports.default = Session;
